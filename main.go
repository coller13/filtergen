package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const filterTemplate = `
// {{.FuncName}} returns a filter function for the field {{.FieldName}}.
func {{.FuncName}}(value {{.FieldType}}) func(item *{{.StructType}}, index int) bool {
	return func(item *{{.StructType}}, index int) bool {
		{{if .IsStruct -}}
		// Compare only exported fields of the struct
		return {{range $index, $field := .ExportedFields -}}
			{{if $index}} && {{end}}item.{{$.FieldName}}.{{$field}} == value.{{$field}}
		{{- end}}
		{{- else -}}
		return item.{{.FieldName}} == value
		{{- end}}
	}
}
`

type FilterData struct {
	FuncName       string
	FieldName      string
	FieldType      string
	StructType     string
	IsStruct       bool
	ExportedFields []string
}

func main() {
	// Parse command-line arguments
	path := flag.String("path", ".", "Path to .go files or directories")
	flag.Parse()

	// Get a list of files to analyze
	files, err := getGoFiles(*path)
	if err != nil {
		log.Fatalf("Error getting files: %v", err)
	}

	// Process each file
	for _, file := range files {
		generateFiltersForFile(file)
	}
}

// getGoFiles returns a list of all .go files in the specified path
func getGoFiles(path string) ([]string, error) {
	var files []string

	err := filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".go") {
			files = append(files, p)
		}
		return nil
	})

	return files, err
}

// generateFiltersForFile generates filters for a file
func generateFiltersForFile(filePath string) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Error reading file %s: %v", filePath, err)
	}

	// Package name
	packageName := node.Name.Name

	// List of generated filters
	var filters []FilterData

	// Map to store struct definitions
	structDefs := make(map[string]*ast.StructType)

	// First pass: collect all struct definitions in the file
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		structDefs[typeSpec.Name.Name] = structType
		return true
	})

	// Second pass: generate filters
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		structName := typeSpec.Name.Name

		for _, field := range structType.Fields.List {
			if field.Doc == nil {
				continue
			}

			for _, comment := range field.Doc.List {
				if strings.Contains(comment.Text, "generate:filter") {
					fieldName := field.Names[0].Name
					fieldType := types.ExprString(field.Type)

					// Check if the field is a struct
					isStruct := false
					var exportedFields []string

					// Handle pointer types
					if starExpr, ok := field.Type.(*ast.StarExpr); ok {
						if ident, ok := starExpr.X.(*ast.Ident); ok {
							if structType, ok := structDefs[ident.Name]; ok {
								isStruct = true
								exportedFields = getExportedFields(structType)
							}
						}
					}

					// Handle non-pointer types
					if ident, ok := field.Type.(*ast.Ident); ok {
						if structType, ok := structDefs[ident.Name]; ok {
							isStruct = true
							exportedFields = getExportedFields(structType)
						}
					}

					filters = append(filters, FilterData{
						FuncName:       fmt.Sprintf("WithFilter%s%s", structName, strings.Title(fieldName)),
						FieldName:      fieldName,
						FieldType:      fieldType,
						StructType:     structName,
						IsStruct:       isStruct,
						ExportedFields: exportedFields,
					})
				}
			}
		}

		return true
	})

	// If no filters are found, do not create a file
	if len(filters) == 0 {
		fmt.Printf("No fields with 'generate:filter' tag found in file %s. File not created.\n", filePath)
		return
	}

	// Output file name
	outputFileName := strings.TrimSuffix(filePath, ".go") + "_filters.go"
	outputFile, err := os.Create(outputFileName)
	if err != nil {
		log.Fatalf("Error creating file %s: %v", outputFileName, err)
	}
	defer outputFile.Close()

	// Write the package directive at the beginning of the file
	_, err = fmt.Fprintf(outputFile, "// Code generated by filtergen. DO NOT EDIT.\n\npackage %s\n\n", packageName)
	if err != nil {
		log.Fatalf("Error writing package directive to file %s: %v", outputFileName, err)
	}

	// Template for generation
	tmpl, err := template.New("filter").Parse(filterTemplate)
	if err != nil {
		log.Fatalf("Error creating template: %v", err)
	}

	// Generate filters
	for _, filter := range filters {
		err := tmpl.Execute(outputFile, filter)
		if err != nil {
			log.Fatalf("Error generating code: %v", err)
		}
	}

	fmt.Printf("File %s successfully generated.\n", outputFileName)
}

// getExportedFields returns a list of exported fields in a struct
func getExportedFields(structType *ast.StructType) []string {
	var fields []string
	for _, field := range structType.Fields.List {
		for _, name := range field.Names {
			if ast.IsExported(name.Name) {
				fields = append(fields, name.Name)
			}
		}
	}
	return fields
}
