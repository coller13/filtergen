package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const filterTemplate = `
// {{.FuncName}} returns a filter function for the field {{.FieldName}}.
func {{.FuncName}}(value {{.FieldType}}) func(item *{{.StructType}}, index int) bool {
    return func(item *{{.StructType}}, index int) bool {
        return item.{{.FieldName}} == value
    }
}
`

type FilterData struct {
	FuncName   string
	FieldName  string
	FieldType  string
	StructType string
}

func main() {
	// Парсинг аргументов командной строки
	path := flag.String("path", ".", "Path to .go files or directories")
	flag.Parse()

	// Получение списка файлов для анализа
	files, err := getGoFiles(*path)
	if err != nil {
		log.Fatalf("Error getting files: %v", err)
	}

	// Обработка каждого файла
	for _, file := range files {
		generateFiltersForFile(file)
	}
}

// getGoFiles возвращает список всех .go файлов по указанному пути
func getGoFiles(path string) ([]string, error) {
	var files []string

	err := filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".go") {
			files = append(files, p)
		}
		return nil
	})

	return files, err
}

// generateFiltersForFile генерирует фильтры для файла
func generateFiltersForFile(filePath string) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Error reading file %s: %v", filePath, err)
	}

	// Имя пакета
	packageName := node.Name.Name

	// Список сгенерированных фильтров
	var filters []FilterData

	// Анализ структуры
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		structName := typeSpec.Name.Name

		for _, field := range structType.Fields.List {
			if field.Doc == nil {
				continue
			}

			for _, comment := range field.Doc.List {
				if strings.Contains(comment.Text, "generate:filter") {
					fieldName := field.Names[0].Name
					fieldType := types.ExprString(field.Type)

					filters = append(filters, FilterData{
						FuncName:   fmt.Sprintf("WithFilter%s%s", structName, strings.Title(fieldName)),
						FieldName:  fieldName,
						FieldType:  fieldType,
						StructType: structName,
					})
				}
			}
		}

		return true
	})

	// Если фильтров нет, не создаем файл
	if len(filters) == 0 {
		fmt.Printf("No fields with 'generate:filter' tag found in file %s. File not created.\n", filePath)
		return
	}

	// Имя выходного файла
	outputFileName := strings.TrimSuffix(filePath, ".go") + "_filters.go"
	outputFile, err := os.Create(outputFileName)
	if err != nil {
		log.Fatalf("Error creating file %s: %v", outputFileName, err)
	}
	defer outputFile.Close()

	// Записываем директиву package в начало файла
	_, err = fmt.Fprintf(outputFile, "// Code generated by filtergen. DO NOT EDIT.\n\npackage %s\n\n", packageName)
	if err != nil {
		log.Fatalf("Error writing package directive to file %s: %v", outputFileName, err)
	}

	// Шаблон для генерации
	tmpl, err := template.New("filter").Parse(filterTemplate)
	if err != nil {
		log.Fatalf("Error creating template: %v", err)
	}

	// Генерация фильтров
	for _, filter := range filters {
		err := tmpl.Execute(outputFile, filter)
		if err != nil {
			log.Fatalf("Error generating code: %v", err)
		}
	}

	fmt.Printf("File %s successfully generated.\n", outputFileName)
}
